import { sql } from "drizzle-orm";
import {
  integer,
  pgTable,
  varchar,
  timestamp,
  serial,
  unique,
  check,
} from "drizzle-orm/pg-core";

const timestamps = {
  updated_at: timestamp(),
  created_at: timestamp().defaultNow().notNull(),
  deleted_at: timestamp(),
};

/*
    User table:
    1. id, primary key, autogenerated
    2. name of user
    3. email of user, unique
    4. password, minimum 8 characters enforced by DB check
    5. polls: (Relation) Queried via PollTable.userId
    6. votes: (Relation) Queried via VoteTable.userId
*/
export const UsersTable = pgTable(
  "users",
  {
    id: serial().primaryKey(),
    name: varchar({ length: 255 }).notNull(),
    email: varchar({ length: 255 }).notNull().unique(),
    password: varchar({ length: 255 }).notNull(),
    ...timestamps,
  },
  (table) => ({
    password_min_length: check(
      "password_min_length",
      sql`length(${table.password}) >= 8`,
    ),
  }),
);

/* Poll table:
    1. id, primary key, autogenerated
    2. question, can't be null
    3. userId, foreign key referencing the user who created this poll
    4. options: (Relation) Queried via OptionTable.pollId
    5. votes: (Relation) Queried via VoteTable.pollId
*/
export const PollTable = pgTable("polls", {
  id: serial().primaryKey(),
  question: varchar({ length: 255 }).notNull(),
  user_id: integer()
    .notNull()
    .references(() => UsersTable.id, { onDelete: "cascade" }),
  ...timestamps,
});

/* Option table:
    1. id, primary key, auto generated
    2. text, text present in the option
    3. pollId, foreign key referencing which poll this option belongs to
    4. votes: (Relation) Queried via VoteTable.optionId
*/
export const OptionTable = pgTable("options", {
  id: serial().primaryKey(),
  text: varchar({ length: 255 }).notNull(),
  poll_id: integer()
    .notNull()
    .references(() => PollTable.id, { onDelete: "cascade" }),
  ...timestamps,
});

/*
    Vote table:
    1. id, primary key, auto generated
    2. userId, foreign key referencing the user who casted this vote
    3. pollId, foreign key referencing the poll being voted on
    4. optionId, foreign key referencing the specific option chosen
    Note: The unique constraint ensures a user can only vote once per poll.
*/
export const VoteTable = pgTable(
  "votes",
  {
    id: serial().primaryKey(),
    user_id: integer()
      .notNull()
      .references(() => UsersTable.id, { onDelete: "cascade" }),
    poll_id: integer()
      .notNull()
      .references(() => PollTable.id, { onDelete: "cascade" }),
    option_id: integer()
      .notNull()
      .references(() => OptionTable.id, { onDelete: "cascade" }),
    ...timestamps,
  },
  (table) => ({
    // This implements your @@unique([userId, pollId]) baseline
    unique_vote_per_user: unique().on(table.userId, table.pollId),
  }),
);
